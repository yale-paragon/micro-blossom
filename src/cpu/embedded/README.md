# Embedded firmware

This project builds firmwares to be run on embedded CPUs like RiscV, Cortex R5 or A72, etc.
The binary could be an executable binary or a static library, etc, depending on the CPU and purpose.
For RiscV, we build the final executable firmware that can be loaded directly into the memory and execute;
for the CPUs in the PS of Xilinx FPGAs, we build static library and then let the Xilinx Vitis toolchain to generate the image.
The different building process is provided in the Makefile and useful information about them are printed out.

In `src/binding.rs` we define several interface functions that needs to be provided either by C or in Rust.
When provided by C, one can compile the Rust program into a static library and link with the C program.
When provided in Rust (e.g. see `src/riscv_driver.rs`), there is no need to do so and we can generate the binary directly.

The entry of the program is `rust_main()` defined in `src/lib.rs`.
When a binary is expected, an entry point must be defined in `src/main.rs` depending on the specific platform.

## RiscV

First we need the RiscV toolchain

```sh
git clone https://github.com/riscv/riscv-gnu-toolchain
cd riscv-gnu-toolchain
git submodule update --init --recursive
# also install any dependencies, see https://github.com/riscv/riscv-gnu-toolchain for more details
./configure --prefix=$HOME/.riscv --enable-multilib
make  # add -j10 to speed up, it takes a while
```

We can build the binary using `make riscv`.
It generates executable binary under `target/riscv32i-unknown-none-elf/(release|debug)/embedded_blossom`.
Note that the linker script is provided at `riscv-memory.x` and user can modify it according to their hardware.

## Processing System of Xilinx FPGAs

A Xilinx SoC usually comes with a PS that combines APUs (application processor) and RPUs (real-time processor).
The APU is either Arm Cortex A53 (Ultrascale+) or A72 (Versal) and the RPU is Arm Cortex R5(F).
The APUs, regardless of its model, runs the same `aarch64` architecture, while the RPUs are `armv7r` architecture.

In order to run a bare-metal program on the Xilinx FPGAs, we need to use Xilinx Vitis toolchain.
Unfortunately it doesn't support Rust programming language.
A workaround is to compile the Rust program into a static library and use Vitis tools to link into the binary.
Vitis takes a hardware platform (a XSA file) that could be generated by Xilinx Vivado.
In order to reduce the effort to learn the tools and automate the design and test process, we develop several scripts that 
can generate the whole program without even opening Vivado or Vitis.
Note that you can also learn how to manually operate in those tools by reading the script, or even copy-paste the commands
into the TCL console provided by Vivado.
