# Embedded firmware

This project builds firmwares to be run on embedded CPUs like RiscV, Cortex R5 or A72, etc.
The binary could be an executable binary or a static library, etc, depending on the CPU and purpose.
For RiscV, we build the final executable firmware that can be loaded directly into the memory and execute;
for the CPUs in the PS of Xilinx FPGAs, we build static library and then let the Xilinx Vitis toolchain to generate the image.
The different building process is provided in the Makefile and useful information about them are printed out.

In `src/binding.rs` we define several interface functions that needs to be provided either by C or in Rust.
When provided by C, one can compile the Rust program into a static library and link with the C program.
When provided in Rust (e.g. see `src/riscv_driver.rs`), there is no need to do so and we can generate the binary directly.

The entry of the program is `rust_main()` defined in `src/lib.rs`.
When a binary is expected, an entry point must be defined in `src/main.rs` depending on the specific platform.
You can find example main functions in the `src/mains` folders.
By default it runs `src/mains/hello_world.rs` but you can change it by `EMBEDDED_BLOSSOM_MAIN=hello_world make`.

## RiscV

First we need the RiscV toolchain

```sh
git clone https://github.com/riscv/riscv-gnu-toolchain
cd riscv-gnu-toolchain
git submodule update --init --recursive
# also install any dependencies, see https://github.com/riscv/riscv-gnu-toolchain for more details
./configure --prefix=$HOME/.riscv --enable-multilib
make  # add -j10 to speed up, it takes a while
```

We can build the binary using `make riscv`.
It generates executable binary under `target/riscv32i-unknown-none-elf/(release|debug)/embedded_blossom`.
Note that the linker script is provided at `riscv-memory.x` and user can modify it according to their hardware.

## PS of Xilinx FPGAs

A Xilinx SoC usually comes with a PS (processing system) that combines APUs (application processor) and RPUs (real-time processor).
The APU is either Arm Cortex A53 (Ultrascale+) or A72 (Versal) and the RPU is Arm Cortex R5(F).
The APUs, regardless of its model, runs the same `aarch64` architecture, while the RPUs are `armv7r` architecture.

In order to run a bare-metal program on the Xilinx FPGAs, we need to use Xilinx Vitis toolchain.
Unfortunately it doesn't support Rust programming language.
A workaround is to compile the Rust program into a static library and use Vitis tools to link into the binary.
Vitis takes a hardware platform (a XSA file) that could be generated by Xilinx Vivado.
In order to reduce the effort to learn the tools and automate the design and test process, we develop several scripts that
can generate the whole program without even opening Vivado or Vitis.
Note that you can also learn how to manually operate in those tools by reading the script, or even copy-paste the commands
into the TCL console provided by Vivado.

```sh
make xilinx  # build static library for both aarch64 and armv7r
```

There are several projects in `src/fpga/Xilinx` folder, see `src/fpga/Xilinx/README.md` for more information.
As an example, the following command will build the whole image of a simple application with 2GB LPDDR4 and 8KB BRAM on the PL
side shared by both A72 and R5F in the Versal VMK180 evaluation borad.
Note that the BRAM is configured to be dual port, so although A72 accesses it using `0xA400_0000` while R5F accesses it using
`0x8000_0000`, they are essentially the same memory.

```sh
# build Rust staticlib
EMBEDDED_BLOSSOM_MAIN=test_bram make xilinx
# build FPGA image including the CPU executable
make -C ../../fpga/Xilinx/VMK180_BRAM
# flash the image and run the program
make -C ../../fpga/Xilinx/VMK180_BRAM run_r5
make -C ../../fpga/Xilinx/VMK180_BRAM run_a72
# if the hardware XSA is not changed, we can avoid reseting the whole system but only reload CPU program
make -C ../../fpga/Xilinx/VMK180_BRAM run_r5_quick
make -C ../../fpga/Xilinx/VMK180_BRAM run_a72_quick
```

If you want to view the content of the compiled static library, you can use the Vitis toolchain like below.
Note that not all functions in the static libraries are referred, and most of them should be removed in the final binary.

```sh
/tools/Xilinx/Vitis/2023.2/gnu/aarch64/lin/aarch64-none/bin/aarch64-none-elf-objdump -d ./target/aarch64-unknown-none/release/libembedded_blossom.a > aarch64.dump
/tools/Xilinx/Vitis/2023.2/gnu/armr5/lin/gcc-arm-none-eabi/bin/armr5-none-eabi-objdump -d ./target/armv7r-none-eabihf/release/libembedded_blossom.a > armv7r.dump
```
